<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gesture Controlled 3D Particles</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { width: 100vw; height: 100vh; overflow: hidden; background: #000; font-family: system-ui, Arial; }
    canvas { display: block; width: 100%; height: 100%; }
    video { position: fixed; bottom: 12px; left: 12px; width: 200px; height: 150px; border-radius: 8px; opacity: 0.8; object-fit: cover; transform: scaleX(-1); }
    #overlay { position: fixed; bottom: 12px; left: 12px; width: 200px; height: 150px; pointer-events: none; }
    #hud { position: fixed; top: 12px; left: 12px; color: #fff; font-size: 13px; background: rgba(0,0,0,0.5); padding: 8px 12px; border-radius: 6px; font-family: monospace; z-index: 10; }
  </style>
</head>
<body>
  <video id="video" autoplay muted playsinline></video>
  <canvas id="overlay" width="200" height="150"></canvas>
  <div id="hud">Initializing...</div>

  <!-- Three.js -->
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- MediaPipe -->
  <script async src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script async src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script async src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script type="module">
    // Wait for Three.js and MediaPipe to load
    let retries = 0;
    const waitForDeps = setInterval(() => {
      if (typeof THREE !== 'undefined' && typeof Hands !== 'undefined' && typeof Camera !== 'undefined') {
        clearInterval(waitForDeps);
        initApp();
      } else if (retries++ > 100) {
        console.error("Failed to load dependencies");
        clearInterval(waitForDeps);
        document.getElementById('hud').textContent = "Error: Failed to load libraries";
      }
    }, 50);

    async function initApp() {
      try {
        // Lazy-load modules
        const { initParticles, updateParticles, setShape, setColor, setMotion, setCenterOffset, setBlendWeights } = await import('./particles.js');
        const { initHandTracking } = await import('./gestures.js');

        let scene, camera, renderer;

        // THREE.js Scene
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        document.body.appendChild(renderer.domElement);

        // Initialize particles
        initParticles(scene);

        // Initialize hand tracking
        let shapeOrder = ["heart", "flower", "saturn", "fireworks"];
        let currentShapeIndex = 0;
        const hudEl = document.getElementById('hud');

        initHandTracking((gesture, expansion, openness, direction, handPos) => {
          if (hudEl) {
            hudEl.innerHTML = `Gesture: <b>${gesture}</b> | Exp: ${(expansion ?? 1).toFixed(1)} | Open: ${(openness ?? 0).toFixed(1)} | Pinch Control: ${gesture === 'PINCH' ? 'ðŸŽ¯' : ''}`;
          }

          // Live hand follow with smooth centering
          if (handPos && typeof handPos.x === 'number') {
            // Smooth hand position tracking
            setCenterOffset(handPos.x, handPos.y, handPos.z);
          }

          // PINCH EXPANSION/REDUCTION: Directly control particle size with thumb-index distance
          if (gesture === 'PINCH') {
            // Expansion is already modified by pinch distance in gestures.js
            // Just pass it directly for pinch expansion/reduction
            setShape(shapeOrder[currentShapeIndex], expansion);
          }

          // Continuous blend based on hand openness
          const wHeart = Math.max(0, Math.min(1, openness * 1.2));
          const wFlower = Math.max(0, Math.min(1, (openness - 0.3) * 1.5));
          const wSaturn = gesture === 'FIST' ? 0.85 : Math.max(0, 0.15 - openness * 0.15);
          const wFire = gesture === 'PINCH' ? 0.8 : Math.max(0, (0.25 - openness) * 0.35);
          let sum = wHeart + wFlower + wSaturn + wFire;
          if (sum < 1e-6) sum = 1;
          setBlendWeights({
            heart: wHeart / sum,
            flower: wFlower / sum,
            saturn: wSaturn / sum,
            fireworks: wFire / sum
          });

          // Motion modes based on gesture type
          if (gesture === 'OPEN') {
            setMotion('pulse');
          } else if (gesture === 'FIST') {
            setMotion('orbit');
          } else if (gesture === 'PINCH') {
            setMotion('swirl');
          }

          // Swipe to cycle shapes
          if (gesture === 'SWIPE') {
            if (direction === 'RIGHT') {
              currentShapeIndex = (currentShapeIndex + 1) % shapeOrder.length;
            } else if (direction === 'LEFT') {
              currentShapeIndex = (currentShapeIndex - 1 + shapeOrder.length) % shapeOrder.length;
            }
            setShape(shapeOrder[currentShapeIndex], expansion);
          }

          // Dynamic color: varies with openness and gesture
          let hue, saturation, brightness;
          if (gesture === 'PINCH') {
            // Pinch: cyan to magenta based on pinch tightness
            hue = 280 + openness * 80; // 280-360 (magenta region)
            saturation = 1;
            brightness = 0.6 + expansion * 0.1;
          } else if (gesture === 'FIST') {
            // Fist: purple to blue
            hue = 240 + openness * 40;
            saturation = 0.9;
            brightness = 0.5 + openness * 0.3;
          } else {
            // Open: pink to cyan
            hue = 300 + openness * 100;
            saturation = 1;
            brightness = 0.6 + openness * 0.2;
          }
          
          // Convert HSB to hex
          const c = brightness * saturation;
          const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
          const m = brightness - c;
          let r = 0, g = 0, b = 0;
          if (hue < 60) { r = c; g = x; }
          else if (hue < 120) { r = x; g = c; }
          else if (hue < 180) { g = c; b = x; }
          else if (hue < 240) { g = x; b = c; }
          else if (hue < 300) { r = x; b = c; }
          else { r = c; b = x; }
          const hex = ((Math.round((r + m) * 255) << 16) | (Math.round((g + m) * 255) << 8) | Math.round((b + m) * 255));
          setColor(hex);
        });

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);
          updateParticles();
          renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
          if (e.key === '1') setShape('heart', 1);
          if (e.key === '2') setShape('flower', 1);
          if (e.key === '3') setShape('saturn', 1);
          if (e.key === '4') setShape('fireworks', 1);
          if (e.key === 'q') setMotion('pulse');
          if (e.key === 'w') setMotion('orbit');
          if (e.key === 'e') setMotion('swirl');
        });

      } catch (err) {
        console.error(err);
        document.getElementById('hud').textContent = "Error: " + err.message;
      }
    }
  </script>
</body>
</html>
</html>
