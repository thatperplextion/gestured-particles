<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gesture Controlled 3D Particles</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { width: 100vw; height: 100vh; overflow: hidden; background: #000; font-family: system-ui, Arial; }
    canvas { display: block; width: 100%; height: 100%; }
    video { position: fixed; bottom: 12px; left: 12px; width: 200px; height: 150px; border-radius: 8px; opacity: 0.8; object-fit: cover; transform: scaleX(-1); }
    #overlay { position: fixed; bottom: 12px; left: 12px; width: 200px; height: 150px; pointer-events: none; }
    #hud { 
      position: fixed; 
      top: 12px; 
      left: 12px; 
      color: #fff; 
      font-size: 12px; 
      background: rgba(0,0,0,0.7); 
      padding: 10px 14px; 
      border-radius: 6px; 
      border: 1px solid rgba(100,200,255,0.3);
      font-family: monospace; 
      z-index: 10; 
      min-width: 280px;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <video id="video" autoplay muted playsinline></video>
  <canvas id="overlay" width="200" height="150"></canvas>
  <div id="hud">Initializing...</div>

  <!-- Three.js -->
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- MediaPipe -->
  <script async src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script async src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script async src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script type="module">
    // Wait for Three.js and MediaPipe to load
    let retries = 0;
    const waitForDeps = setInterval(() => {
      const hasThree = typeof window.THREE !== 'undefined';
      const hasHands = typeof window.Hands !== 'undefined';
      const hasCamera = typeof window.Camera !== 'undefined';
      
      if (hasThree && hasHands && hasCamera) {
        clearInterval(waitForDeps);
        initApp();
      } else if (retries++ > 100) {
        console.error("Failed to load dependencies. THREE:", hasThree, "Hands:", hasHands, "Camera:", hasCamera);
        clearInterval(waitForDeps);
        document.getElementById('hud').innerHTML = `<span style="color:#ff6b6b;">‚ùå Error: Libraries failed to load</span>`;
      }
    }, 50);

    async function initApp() {
      try {
        // Lazy-load modules
        const { initParticles, updateParticles, setShape, setColor, setMotion, setCenterOffset, setBlendWeights } = await import('./particles.js');
        const { initHandTracking } = await import('./gestures.js');
        const { AudioFeedback } = await import('./audio.js');
        const { SettingsPanel } = await import('./settings.js');
        const { PerformanceDashboard } = await import('./performance.js');
        const { ParticleTrail } = await import('./trail.js');
        const { ScreenRecorder } = await import('./recorder.js');

        let scene, camera, renderer;

        // THREE.js Scene
        const THREE = window.THREE;
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        document.body.appendChild(renderer.domElement);

        // Initialize enhanced features
        const audioFeedback = new AudioFeedback();
        const settings = new SettingsPanel();
        const performance = new PerformanceDashboard();
        const trail = new ParticleTrail(2000);
        const recorder = new ScreenRecorder(renderer.domElement);

        // Initialize particles
        initParticles(scene);
        trail.initTrailSystem(scene);

        // Initialize hand tracking
        let shapeOrder = ["heart", "flower", "saturn", "fireworks"];
        let currentShapeIndex = 0;
        const hudEl = document.getElementById('hud');
        let lastHandPos = null;

        initHandTracking((gesture, expansion, openness, direction, handPos) => {
          if (hudEl) {
            hudEl.innerHTML = `Gesture: <b>${gesture}</b> | Exp: ${(expansion ?? 1).toFixed(1)} | Open: ${(openness ?? 0).toFixed(1)} | 5-Finger Control: üñêÔ∏è`;
          }

          // Audio feedback for gestures
          if (settings.settings.audioEnabled) {
            audioFeedback.playGestureSound(gesture);
            if (gesture === 'SWIPE') {
              audioFeedback.playSwipeSound(direction);
            }
          }

          // Live hand follow with smooth centering
          if (handPos && typeof handPos.x === 'number') {
            // Smooth hand position tracking
            setCenterOffset(handPos.x, handPos.y, handPos.z);
            lastHandPos = handPos;

            // Update performance metrics
            performance.setHandSpeed(expansion - 1);
          }

          // FIVE-FINGER EXPANSION/REDUCTION: Direct control with all fingers
          // Compress all fingers = contract, open all fingers = expand
          setShape(shapeOrder[currentShapeIndex], expansion);

          // ADVANCED BLEND WEIGHT MAPPING based on gesture and openness
          // This creates smooth transitions between shapes based on hand compression
          
          // Normalize openness to 0-1 range (0 = fist, 1 = fully open)
          const normalizedOpenness = Math.max(0, Math.min(1, openness));
          
          // Base blend weights for each gesture state
          let wHeart = 0, wFlower = 0, wSaturn = 0, wFire = 0;
          
          if (gesture === 'FIST') {
            // FIST STATE: Maximize fireworks, minimize open shapes
            wFire = 0.9;
            wSaturn = 0.4;
            wHeart = 0.1 * normalizedOpenness;
            wFlower = 0.05 * normalizedOpenness;
          } else if (gesture === 'PINCH') {
            // PINCH STATE: Mix saturn and fireworks, slight heart influence
            // As fingers open more during pinch, transition to saturn
            wSaturn = 0.5 + normalizedOpenness * 0.3;
            wFire = 0.7 - normalizedOpenness * 0.2;
            wHeart = 0.3 * normalizedOpenness;
            wFlower = 0.2 * normalizedOpenness;
          } else {
            // OPEN STATE: Primarily heart and flower, influenced by openness degree
            // Fully open = maximum heart, moderately open = flower blend
            wHeart = 0.4 + normalizedOpenness * 0.6; // 0.4-1.0
            wFlower = Math.max(0, (normalizedOpenness - 0.3) * 1.2); // ramps up after 30% open
            wSaturn = Math.max(0, 0.2 - normalizedOpenness * 0.1); // decreases as hand opens
            wFire = Math.max(0, 0.15 - normalizedOpenness * 0.15); // minimal in open state
          }
          
          // Normalize weights to sum to 1.0
          let sum = wHeart + wFlower + wSaturn + wFire;
          if (sum < 1e-6) sum = 1;
          
          setBlendWeights({
            heart: wHeart / sum,
            flower: wFlower / sum,
            saturn: wSaturn / sum,
            fireworks: wFire / sum
          });

          // Motion modes based on five-finger compression state
          if (gesture === 'OPEN') {
            // All fingers open: gentle pulse
            setMotion('pulse');
          } else if (gesture === 'PINCH') {
            // Moderate compression: spiral swirl
            setMotion('swirl');
          } else if (gesture === 'FIST') {
            // All fingers closed: fast orbit
            setMotion('orbit');
          }

          // Swipe to cycle shapes
          if (gesture === 'SWIPE') {
            if (direction === 'RIGHT') {
              currentShapeIndex = (currentShapeIndex + 1) % shapeOrder.length;
            } else if (direction === 'LEFT') {
              currentShapeIndex = (currentShapeIndex - 1 + shapeOrder.length) % shapeOrder.length;
            }
            setShape(shapeOrder[currentShapeIndex], expansion);
          }

          // Dynamic color: varies with five-finger compression and hand openness
          let hue, saturation, brightness;
          if (gesture === 'FIST') {
            // Fully compressed: deep red/magenta
            hue = 300 + openness * 40;
            saturation = 0.95;
            brightness = 0.5 + expansion * 0.15;
          } else if (gesture === 'PINCH') {
            // Moderately compressed: purple to blue
            hue = 240 + openness * 50;
            saturation = 0.9;
            brightness = 0.55 + openness * 0.25;
          } else {
            // Fully open: cyan to pink (rainbow effect)
            hue = 180 + openness * 120;
            saturation = 1;
            brightness = 0.65 + openness * 0.25;
          }
          
          // Convert HSB to hex
          const c = brightness * saturation;
          const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
          const m = brightness - c;
          let r = 0, g = 0, b = 0;
          if (hue < 60) { r = c; g = x; }
          else if (hue < 120) { r = x; g = c; }
          else if (hue < 180) { g = c; b = x; }
          else if (hue < 240) { g = x; b = c; }
          else if (hue < 300) { r = x; b = c; }
          else { r = c; b = x; }
          const hex = ((Math.round((r + m) * 255) << 16) | (Math.round((g + m) * 255) << 8) | Math.round((b + m) * 255));
          setColor(hex);
          trail.setColor(hex);
        });

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);
          
          // Update performance metrics
          performance.update();
          
          // Update particles with trails
          updateParticles();
          
          // Record particle positions for trails
          if (settings.settings.trailEnabled) {
            const pos = geometry.attributes.position.array;
            trail.recordAllPositions(pos, 2000);
            trail.updateTrailMesh();
          }
          
          renderer.render(scene, camera);
        }
        animate();

        // Listen for settings changes
        window.addEventListener('settingsChanged', (e) => {
          const newSettings = e.detail;
          if (newSettings.audioVolume) {
            audioFeedback.setVolume(newSettings.audioVolume);
          }
          if (newSettings.trailLength !== undefined) {
            trail.setTrailLength(newSettings.trailLength);
          }
          if (newSettings.trailEnabled !== undefined) {
            trail.setEnabled(newSettings.trailEnabled);
          }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
          if (e.key === '1') setShape('heart', 1);
          if (e.key === '2') setShape('flower', 1);
          if (e.key === '3') setShape('saturn', 1);
          if (e.key === '4') setShape('fireworks', 1);
          if (e.key === 'q') setMotion('pulse');
          if (e.key === 'w') setMotion('orbit');
          if (e.key === 'e') setMotion('swirl');
        });

      } catch (err) {
        console.error(err);
        document.getElementById('hud').textContent = "Error: " + err.message;
      }
    }
  </script>
</body>
</html>
</html>
