<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gesture Controlled 3D Particles</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { width: 100vw; height: 100vh; overflow: hidden; background: #000; font-family: system-ui, Arial; }
    canvas { display: block; width: 100%; height: 100%; }
    video { position: fixed; bottom: 12px; left: 12px; width: 200px; height: 150px; border-radius: 8px; opacity: 0.8; object-fit: cover; transform: scaleX(-1); z-index: 5; }
    #overlay { position: fixed; bottom: 12px; left: 12px; width: 200px; height: 150px; pointer-events: none; z-index: 6; }
    #hud { 
      position: fixed; 
      top: 12px; 
      left: 12px; 
      color: #fff; 
      font-size: 12px; 
      background: rgba(0,0,0,0.7); 
      padding: 10px 14px; 
      border-radius: 6px; 
      border: 1px solid rgba(100,200,255,0.3);
      font-family: monospace; 
      z-index: 20; 
      min-width: 280px;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <video id="video" autoplay muted playsinline></video>
  <canvas id="overlay" width="200" height="150"></canvas>
  <div id="hud">Initializing...</div>

  <!-- Three.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- MediaPipe CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
    // ====== GLOBAL STATE - GALAXY SYSTEM ======
    const THREE = window.THREE;
    let scene, camera, renderer, geometry, material, points;
    let positions, velocities;
    const PARTICLE_COUNT = 3000; // More particles for galaxy effect
    let centerOffset = { x: 0, y: 0, z: 0 };
    let time = 0;
    let motionMode = "galaxy";
    let currentExpansion = 1;
    let targetExpansion = 1;
    let particleColor = 0x4488ff;
    let galaxyRotation = 0;
    let galaxySpeed = 0.002;
    let spiralTightness = 1.0;
    let handInfluence = { x: 0, y: 0, z: 0 };
    
    // Galaxy shape data - spiral arms
    let galaxyPositions = [];

    // ====== GALAXY GENERATION ======
    function generateGalaxy() {
      galaxyPositions = Array.from({ length: PARTICLE_COUNT }, (_, i) => {
        // Create spiral galaxy with multiple arms
        const armIndex = i % 4; // 4 spiral arms
        const armOffset = (armIndex * Math.PI * 2) / 4;
        
        // Distance from center (0 to 4 units)
        const radius = Math.pow(Math.random(), 0.8) * 4;
        
        // Spiral angle based on distance
        const spiralAngle = radius * 0.8 + armOffset;
        
        // Add some randomness to make it look natural
        const randomAngle = (Math.random() - 0.5) * 0.5;
        const randomRadius = (Math.random() - 0.5) * 0.3;
        
        const finalAngle = spiralAngle + randomAngle;
        const finalRadius = radius + randomRadius;
        
        // Convert to cartesian coordinates
        const x = Math.cos(finalAngle) * finalRadius;
        const z = Math.sin(finalAngle) * finalRadius;
        
        // Add some vertical variation (galaxy thickness)
        const y = (Math.random() - 0.5) * Math.exp(-radius * 0.5) * 0.8;
        
        return { x, y, z, originalRadius: finalRadius, originalAngle: finalAngle };
      });
    }

    // ====== SHAPE GENERATION ======
    function generateShapes() {
      shapePositions.heart = Array.from({ length: PARTICLE_COUNT }, () => {
        const t = Math.random() * Math.PI * 2;
        return {
          x: 16 * Math.pow(Math.sin(t), 3) * 0.15,
          y: (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.15,
          z: (Math.random() - 0.5) * 0.5
        };
      });

      shapePositions.flower = Array.from({ length: PARTICLE_COUNT }, () => {
        const t = Math.random() * Math.PI * 2;
        const r = Math.cos(5 * t) * 1.2;
        return {
          x: Math.cos(t) * r,
          y: Math.sin(t) * r,
          z: (Math.random() - 0.5) * 0.3
        };
      });

      shapePositions.saturn = Array.from({ length: PARTICLE_COUNT }, () => {
        const a = Math.random() * Math.PI * 2;
        const r = 1.5 + Math.random() * 0.2;
        return {
          x: Math.cos(a) * r,
          y: (Math.random() - 0.5) * 0.1,
          z: Math.sin(a) * r
        };
      });

      shapePositions.fireworks = Array.from({ length: PARTICLE_COUNT }, () => {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * 2;
        return {
          x: Math.cos(a) * r,
          y: Math.sin(a) * r,
          z: (Math.random() - 0.5) * r
        };
      });
    }

    // ====== THREE.JS INIT ======
    function initThreeJS() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 12; // Moved back to see the galaxy better
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000008, 1); // Deep space blue-black
      document.body.appendChild(renderer.domElement);

      // Galaxy particles
      geometry = new THREE.BufferGeometry();
      positions = new Float32Array(PARTICLE_COUNT * 3);
      velocities = new Float32Array(PARTICLE_COUNT * 3);
      
      // Add colors for each particle
      const colors = new Float32Array(PARTICLE_COUNT * 3);
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      material = new THREE.PointsMaterial({
        size: 0.08,
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending // Makes particles glow
      });

      points = new THREE.Points(geometry, material);
      scene.add(points);

      // Generate galaxy
      generateGalaxy();
      
      // Initialize particle colors based on distance from center
      updateGalaxyColors();

      // Start animation
      animate();

      // Resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      document.getElementById('hud').textContent = "✓ Galaxy initialized. Control with hand gestures...";
    }

    // ====== ANIMATION LOOP ======
    function animate() {
      requestAnimationFrame(animate);

      time += 0.016;
      currentExpansion += (targetExpansion - currentExpansion) * 0.05;

      const pos = geometry.attributes.position.array;
      
      // Update each particle
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        // Blend shapes
        let tx = 0, ty = 0, tz = 0;
        
        if (shapePositions.heart[i]) {
          tx += shapePositions.heart[i].x * blend.heart;
          ty += shapePositions.heart[i].y * blend.heart;
          tz += shapePositions.heart[i].z * blend.heart;
        }
        if (shapePositions.flower[i]) {
          tx += shapePositions.flower[i].x * blend.flower;
          ty += shapePositions.flower[i].y * blend.flower;
          tz += shapePositions.flower[i].z * blend.flower;
        }
        if (shapePositions.saturn[i]) {
          tx += shapePositions.saturn[i].x * blend.saturn;
          ty += shapePositions.saturn[i].y * blend.saturn;
          tz += shapePositions.saturn[i].z * blend.saturn;
        }
        if (shapePositions.fireworks[i]) {
          tx += shapePositions.fireworks[i].x * blend.fireworks;
          ty += shapePositions.fireworks[i].y * blend.fireworks;
          tz += shapePositions.fireworks[i].z * blend.fireworks;
        }

        const targetX = tx * currentExpansion + centerOffset.x;
        const targetY = ty * currentExpansion + centerOffset.y;
        const targetZ = tz * currentExpansion + centerOffset.z;

        // Physics
        const dx = targetX - pos[i*3];
        const dy = targetY - pos[i*3+1];
        const dz = targetZ - pos[i*3+2];

        let followGain = 0.15;
        velocities[i*3] += dx * followGain;
        velocities[i*3+1] += dy * followGain;
        velocities[i*3+2] += dz * followGain;

        const damping = 0.92;
        velocities[i*3] *= damping;
        velocities[i*3+1] *= damping;
        velocities[i*3+2] *= damping;

        pos[i*3] += velocities[i*3];
        pos[i*3+1] += velocities[i*3+1];
        pos[i*3+2] += velocities[i*3+2];

        // Motion modes
        if (motionMode === "orbit") {
          const rotSpeed = 0.004;
          const dx2 = pos[i*3] - centerOffset.x;
          const dz2 = pos[i*3+2] - centerOffset.z;
          const cos_a = Math.cos(rotSpeed);
          const sin_a = Math.sin(rotSpeed);
          pos[i*3] = centerOffset.x + (dx2 * cos_a - dz2 * sin_a);
          pos[i*3+2] = centerOffset.z + (dx2 * sin_a + dz2 * cos_a);
        } else if (motionMode === "pulse") {
          const pulseMag = 1 + Math.sin(time * 1.2) * 0.035;
          const dist = Math.sqrt(
            Math.pow(pos[i*3] - centerOffset.x, 2) + 
            Math.pow(pos[i*3+1] - centerOffset.y, 2) + 
            Math.pow(pos[i*3+2] - centerOffset.z, 2)
          );
          if (dist > 0.01) {
            const scale = pulseMag / (dist + 0.1);
            pos[i*3] = centerOffset.x + (pos[i*3] - centerOffset.x) * scale;
            pos[i*3+1] = centerOffset.y + (pos[i*3+1] - centerOffset.y) * scale;
            pos[i*3+2] = centerOffset.z + (pos[i*3+2] - centerOffset.z) * scale;
          }
        }
      }

      geometry.attributes.position.needsUpdate = true;
      renderer.render(scene, camera);
    }

    // ====== HAND TRACKING ======
    function initHandTracking() {
      const video = document.getElementById('video');
      const overlay = document.getElementById('overlay');
      const ctx = overlay.getContext('2d');
      const hudEl = document.getElementById('hud');

      const hands = new window.Hands({
        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
        modelComplexity: 1,
        selfieMode: true
      });

      hands.onResults(results => {
        ctx.clearRect(0, 0, overlay.width, overlay.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          const lm = results.multiHandLandmarks[0];
          const tips = [4, 8, 12, 16, 20];

          // Draw connections
          ctx.strokeStyle = "rgba(0,255,200,0.9)";
          ctx.lineWidth = 2;
          tips.forEach(i => {
            ctx.beginPath();
            ctx.moveTo(lm[i].x * overlay.width, lm[i].y * overlay.height);
            ctx.lineTo(lm[0].x * overlay.width, lm[0].y * overlay.height);
            ctx.stroke();
          });

          // Draw points
          ctx.fillStyle = "rgba(255,255,255,0.9)";
          for (let i = 0; i < lm.length; i++) {
            ctx.beginPath();
            ctx.arc(lm[i].x * overlay.width, lm[i].y * overlay.height, i % 4 === 0 ? 3 : 2, 0, Math.PI * 2);
            ctx.fill();
          }

          // ===== REAL-TIME HAND FOLLOWING =====
          const palm = lm[0];
          centerOffset.x = (palm.x - 0.5) * 6;
          centerOffset.y = (0.5 - palm.y) * 6;
          centerOffset.z = 0;

          // Compression calculation - check all 5 fingertips
          const thumb = lm[4];
          const index = lm[8];
          const middle = lm[12];
          const ring = lm[16];
          const pinky = lm[20];
          const palmBase = lm[0];
          
          // Calculate average distance of all fingertips from palm
          const allDistances = [
            Math.sqrt(Math.pow(thumb.x - palmBase.x, 2) + Math.pow(thumb.y - palmBase.y, 2) + Math.pow(thumb.z - palmBase.z, 2)),
            Math.sqrt(Math.pow(index.x - palmBase.x, 2) + Math.pow(index.y - palmBase.y, 2) + Math.pow(index.z - palmBase.z, 2)),
            Math.sqrt(Math.pow(middle.x - palmBase.x, 2) + Math.pow(middle.y - palmBase.y, 2) + Math.pow(middle.z - palmBase.z, 2)),
            Math.sqrt(Math.pow(ring.x - palmBase.x, 2) + Math.pow(ring.y - palmBase.y, 2) + Math.pow(ring.z - palmBase.z, 2)),
            Math.sqrt(Math.pow(pinky.x - palmBase.x, 2) + Math.pow(pinky.y - palmBase.y, 2) + Math.pow(pinky.z - palmBase.z, 2))
          ];
          
          const avgDistance = allDistances.reduce((a, b) => a + b) / 5;
          const maxDistance = Math.max(...allDistances);
          const minDistance = Math.min(...allDistances);
          
          // Compression ratio: how closed is the fist (0-1, where 0 = fist, 1 = open)
          const closedThreshold = 0.05;  // fully closed fist (more sensitive)
          const openThreshold = 0.12;    // fully open hand (lower threshold)
          let compression = Math.max(0, Math.min(1, (avgDistance - closedThreshold) / (openThreshold - closedThreshold)));
          const expansion = 0.5 + compression * 2.5;

          // Gesture detection with better thresholds
          let gesture = "OPEN";
          if (compression < 0.15) {
            gesture = "FIST";  // Much more sensitive
          } else if (compression < 0.40) {
            gesture = "PINCH"; // Moderately closed
          } else {
            gesture = "OPEN";  // Open hand
          }

          // Shape blending based on gesture
          if (gesture === "FIST") {
            blend = { heart: 0.1, flower: 0.05, saturn: 0.4, fireworks: 0.9 };
            motionMode = "orbit";
          } else if (gesture === "PINCH") {
            blend = { heart: 0.3, flower: 0.2, saturn: 0.6, fireworks: 0.5 };
            motionMode = "swirl";
          } else {
            blend = { heart: 0.8, flower: 0.6, saturn: 0.1, fireworks: 0.1 };
            motionMode = "pulse";
          }

          targetExpansion = expansion;

          // Update color based on gesture
          if (gesture === "FIST") {
            particleColor = 0xff0066;
          } else if (gesture === "PINCH") {
            particleColor = 0x6600ff;
          } else {
            particleColor = 0x00ffff;
          }
          material.color.setHex(particleColor);

          // Update HUD
          hudEl.innerHTML = `
            <div style="color: #0ff;">✓ Hand Detected</div>
            <div>Gesture: <b>${gesture}</b></div>
            <div>Expansion: ${expansion.toFixed(2)}</div>
            <div>Compression: ${(compression * 100).toFixed(0)}%</div>
            <div>Position: (${centerOffset.x.toFixed(1)}, ${centerOffset.y.toFixed(1)})</div>
          `;
        } else {
          hudEl.innerHTML = `<div style="color: #f00;">❌ No hand detected - Please show your hand to camera</div>`;
        }
      });

      const camera = new window.Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 640,
        height: 480
      });

      camera.start();
    }

    // ====== STARTUP ======
    window.addEventListener('load', () => {
      if (typeof THREE !== 'undefined' && typeof window.Hands !== 'undefined' && typeof window.Camera !== 'undefined') {
        initThreeJS();
        initHandTracking();
      } else {
        setTimeout(() => {
          if (typeof THREE !== 'undefined' && typeof window.Hands !== 'undefined' && typeof window.Camera !== 'undefined') {
            initThreeJS();
            initHandTracking();
          } else {
            document.getElementById('hud').innerHTML = '<div style="color:#ff6b6b;">❌ Failed to load libraries</div>';
          }
        }, 1000);
      }
    });
  </script>
</body>
</html>
</html>
