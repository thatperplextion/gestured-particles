<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gesture Controlled 3D Particles</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { width: 100vw; height: 100vh; overflow: hidden; background: #000; font-family: system-ui, Arial; }
    canvas { display: block; width: 100%; height: 100%; }
    video { position: fixed; bottom: 12px; left: 12px; width: 200px; height: 150px; border-radius: 8px; opacity: 0.8; object-fit: cover; transform: scaleX(-1); z-index: 5; }
    #overlay { position: fixed; bottom: 12px; left: 12px; width: 200px; height: 150px; pointer-events: none; z-index: 6; }
    #hud { 
      position: fixed; 
      top: 12px; 
      left: 12px; 
      color: #fff; 
      font-size: 12px; 
      background: rgba(0,0,0,0.7); 
      padding: 10px 14px; 
      border-radius: 6px; 
      border: 1px solid rgba(100,200,255,0.3);
      font-family: monospace; 
      z-index: 20; 
      min-width: 280px;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <video id="video" autoplay muted playsinline></video>
  <canvas id="overlay" width="200" height="150"></canvas>
  <div id="hud">Initializing...</div>

  <!-- Three.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- MediaPipe CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
    // ====== GLOBAL STATE - GALAXY SYSTEM ======
    const THREE = window.THREE;
    let scene, camera, renderer, geometry, material, points;
    let positions, velocities;
    const PARTICLE_COUNT = 3000; // More particles for galaxy effect
    let centerOffset = { x: 0, y: 0, z: 0 };
    let time = 0;
    let motionMode = "galaxy";
    let currentExpansion = 1;
    let targetExpansion = 1;
    let particleColor = 0x4488ff;
    let galaxyRotation = 0;
    let galaxySpeed = 0.002;
    let spiralTightness = 1.0;
    let handInfluence = { x: 0, y: 0, z: 0 };
    let currentGesture = "OPEN_PALM";
    let currentCompression = 0;
    
    // Galaxy shape data - spiral arms
    let galaxyPositions = [];

    // ====== GALAXY GENERATION ======
    function generateGalaxy() {
      galaxyPositions = Array.from({ length: PARTICLE_COUNT }, (_, i) => {
        // Create spiral galaxy with multiple arms
        const armIndex = i % 4; // 4 spiral arms
        const armOffset = (armIndex * Math.PI * 2) / 4;
        
        // Distance from center (0 to 4 units)
        const radius = Math.pow(Math.random(), 0.8) * 4;
        
        // Spiral angle based on distance
        const spiralAngle = radius * 0.8 + armOffset;
        
        // Add some randomness to make it look natural
        const randomAngle = (Math.random() - 0.5) * 0.5;
        const randomRadius = (Math.random() - 0.5) * 0.3;
        
        const finalAngle = spiralAngle + randomAngle;
        const finalRadius = radius + randomRadius;
        
        // Convert to cartesian coordinates
        const x = Math.cos(finalAngle) * finalRadius;
        const z = Math.sin(finalAngle) * finalRadius;
        
        // Add some vertical variation (galaxy thickness)
        const y = (Math.random() - 0.5) * Math.exp(-radius * 0.5) * 0.8;
        
        return { x, y, z, originalRadius: finalRadius, originalAngle: finalAngle };
      });
    }

    // ====== SHAPE GENERATION ======
    function generateShapes() {
      shapePositions.heart = Array.from({ length: PARTICLE_COUNT }, () => {
        const t = Math.random() * Math.PI * 2;
        return {
          x: 16 * Math.pow(Math.sin(t), 3) * 0.15,
          y: (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.15,
          z: (Math.random() - 0.5) * 0.5
        };
      });

      shapePositions.flower = Array.from({ length: PARTICLE_COUNT }, () => {
        const t = Math.random() * Math.PI * 2;
        const r = Math.cos(5 * t) * 1.2;
        return {
          x: Math.cos(t) * r,
          y: Math.sin(t) * r,
          z: (Math.random() - 0.5) * 0.3
        };
      });

      shapePositions.saturn = Array.from({ length: PARTICLE_COUNT }, () => {
        const a = Math.random() * Math.PI * 2;
        const r = 1.5 + Math.random() * 0.2;
        return {
          x: Math.cos(a) * r,
          y: (Math.random() - 0.5) * 0.1,
          z: Math.sin(a) * r
        };
      });

      shapePositions.fireworks = Array.from({ length: PARTICLE_COUNT }, () => {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * 2;
        return {
          x: Math.cos(a) * r,
          y: Math.sin(a) * r,
          z: (Math.random() - 0.5) * r
        };
      });
    }

    // ====== THREE.JS INIT ======
    function initThreeJS() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 12; // Moved back to see the galaxy better
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000008, 1); // Deep space blue-black
      document.body.appendChild(renderer.domElement);

      // Galaxy particles
      geometry = new THREE.BufferGeometry();
      positions = new Float32Array(PARTICLE_COUNT * 3);
      velocities = new Float32Array(PARTICLE_COUNT * 3);
      
      // Add colors for each particle
      const colors = new Float32Array(PARTICLE_COUNT * 3);
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      material = new THREE.PointsMaterial({
        size: 0.08,
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending // Makes particles glow
      });

      points = new THREE.Points(geometry, material);
      scene.add(points);

      // Generate galaxy
      generateGalaxy();
      
      // Initialize particle colors based on distance from center
      updateGalaxyColors();

      // Start animation
      animate();

      // Resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      document.getElementById('hud').textContent = "‚úì Galaxy initialized. Control with hand gestures...";
    }

    // ====== GALAXY ANIMATION ======
    function animate() {
      requestAnimationFrame(animate);

      time += 0.016;
      currentExpansion += (targetExpansion - currentExpansion) * 0.02; // Smoother transitions

      const pos = geometry.attributes.position.array;
      const colors = geometry.attributes.color.array;
      
      // Smooth hand influence
      handInfluence.x += (centerOffset.x - handInfluence.x) * 0.05;
      handInfluence.y += (centerOffset.y - handInfluence.y) * 0.05;
      handInfluence.z += (centerOffset.z - handInfluence.z) * 0.05;
      
      // Galaxy rotation based on expansion (closed fist = faster rotation)
      const rotationSpeed = galaxySpeed * (2.0 - currentExpansion);
      galaxyRotation += rotationSpeed;
      
      // Update each particle
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const galaxyParticle = galaxyPositions[i];
        
        // Calculate spiral position with rotation
        const rotatedAngle = galaxyParticle.originalAngle + galaxyRotation * (1 + galaxyParticle.originalRadius * 0.1);
        
        // Base spiral position
        let targetX = Math.cos(rotatedAngle) * galaxyParticle.originalRadius * currentExpansion;
        let targetY = galaxyParticle.y * currentExpansion;
        let targetZ = Math.sin(rotatedAngle) * galaxyParticle.originalRadius * currentExpansion;
        
        // Add hand influence (galaxy follows hand movement)
        const handStrength = 0.3;
        targetX += handInfluence.x * handStrength;
        targetY += handInfluence.y * handStrength;
        targetZ += handInfluence.z * handStrength;
        
        // Add some orbital motion variation
        const orbitalInfluence = Math.sin(time * 0.5 + galaxyParticle.originalRadius) * 0.1;
        targetX += orbitalInfluence * Math.cos(rotatedAngle + Math.PI/2);
        targetZ += orbitalInfluence * Math.sin(rotatedAngle + Math.PI/2);
        
        // Physics - smooth movement towards target
        const followGain = 0.08; // Slower, more graceful movement
        const dx = targetX - pos[i*3];
        const dy = targetY - pos[i*3+1];
        const dz = targetZ - pos[i*3+2];

        velocities[i*3] += dx * followGain;
        velocities[i*3+1] += dy * followGain;
        velocities[i*3+2] += dz * followGain;

        // Damping for smooth motion
        const damping = 0.95;
        velocities[i*3] *= damping;
        velocities[i*3+1] *= damping;
        velocities[i*3+2] *= damping;

        pos[i*3] += velocities[i*3];
        pos[i*3+1] += velocities[i*3+1];
        pos[i*3+2] += velocities[i*3+2];
        
        // Dynamic colors based on gesture and distance
        const distanceFromCenter = Math.sqrt(pos[i*3]*pos[i*3] + pos[i*3+1]*pos[i*3+1] + pos[i*3+2]*pos[i*3+2]);
        const normalizedDistance = Math.min(1, distanceFromCenter / 6);
        
        // Color schemes that change with gesture
        let centerColor, edgeColor, brightness;
        
        if (currentGesture === "FIST") {
          // Intense red-orange for contracted state
          centerColor = { r: 1.0, g: 0.2, b: 0.1 };
          edgeColor = { r: 1.0, g: 0.4, b: 0.0 };
          brightness = 1.2 + (2.0 - currentExpansion) * 0.3; // Brighter core when contracted
        } else if (currentGesture === "PINCH") {
          // Purple-magenta for intermediate state
          centerColor = { r: 0.8, g: 0.1, b: 1.0 };
          edgeColor = { r: 1.0, g: 0.3, b: 0.8 };
          brightness = 0.9;
        } else {
          // Cool blue-cyan for expanded state
          centerColor = { r: 0.3, g: 0.5, b: 1.0 };
          edgeColor = { r: 0.0, g: 0.8, b: 1.0 };
          brightness = 0.7;
        }
        
        // Interpolate colors
        colors[i*3] = (centerColor.r + (edgeColor.r - centerColor.r) * normalizedDistance) * brightness;
        colors[i*3+1] = (centerColor.g + (edgeColor.g - centerColor.g) * normalizedDistance) * brightness;
        colors[i*3+2] = (centerColor.b + (edgeColor.b - centerColor.b) * normalizedDistance) * brightness;
      }

      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.color.needsUpdate = true;
      renderer.render(scene, camera);
    }
    
    function updateGalaxyColors(gesture = "OPEN_PALM", compression = 0) {
      const colors = geometry.attributes.color.array;
      
      // Dynamic color scheme based on gesture
      let centerColor, edgeColor, intensity;
      
      if (gesture === "FIST") {
        // Intense red-orange for contracted state
        centerColor = { r: 1.0, g: 0.2, b: 0.1 };
        edgeColor = { r: 1.0, g: 0.4, b: 0.0 };
        intensity = 1.2;
      } else if (gesture === "PINCH") {
        // Purple-magenta for intermediate state
        centerColor = { r: 0.8, g: 0.1, b: 1.0 };
        edgeColor = { r: 1.0, g: 0.3, b: 0.8 };
        intensity = 1.0;
      } else {
        // Cool blue-cyan for expanded state
        centerColor = { r: 0.1, g: 0.3, b: 1.0 };
        edgeColor = { r: 0.0, g: 0.8, b: 1.0 };
        intensity = 0.8;
      }
      
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const distance = Math.min(galaxyPositions[i].originalRadius / 4, 1.0); // Normalize 0-1
        
        // Interpolate colors based on distance
        const r = centerColor.r + (edgeColor.r - centerColor.r) * distance;
        const g = centerColor.g + (edgeColor.g - centerColor.g) * distance;
        const b = centerColor.b + (edgeColor.b - centerColor.b) * distance;
        
        // Apply intensity and slight shimmer
        const shimmer = 0.9 + 0.1 * Math.sin(Date.now() * 0.003 + distance * 10);
        colors[i*3] = r * intensity * shimmer;
        colors[i*3+1] = g * intensity * shimmer;
        colors[i*3+2] = b * intensity * shimmer;
      }
      
      geometry.attributes.color.needsUpdate = true;
    }

    // ====== HAND TRACKING ======
    function initHandTracking() {
      const video = document.getElementById('video');
      const overlay = document.getElementById('overlay');
      const ctx = overlay.getContext('2d');
      const hudEl = document.getElementById('hud');

      const hands = new window.Hands({
        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
        modelComplexity: 1,
        selfieMode: true
      });

      hands.onResults(results => {
        ctx.clearRect(0, 0, overlay.width, overlay.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          const lm = results.multiHandLandmarks[0];
          const tips = [4, 8, 12, 16, 20];

          // Draw connections
          ctx.strokeStyle = "rgba(0,255,200,0.9)";
          ctx.lineWidth = 2;
          tips.forEach(i => {
            ctx.beginPath();
            ctx.moveTo(lm[i].x * overlay.width, lm[i].y * overlay.height);
            ctx.lineTo(lm[0].x * overlay.width, lm[0].y * overlay.height);
            ctx.stroke();
          });

          // Draw points
          ctx.fillStyle = "rgba(255,255,255,0.9)";
          for (let i = 0; i < lm.length; i++) {
            ctx.beginPath();
            ctx.arc(lm[i].x * overlay.width, lm[i].y * overlay.height, i % 4 === 0 ? 3 : 2, 0, Math.PI * 2);
            ctx.fill();
          }

          // ===== GALAXY HAND CONTROL =====
          const palm = lm[0];
          centerOffset.x = (palm.x - 0.5) * 8;  // Increased range for galaxy movement
          centerOffset.y = (0.5 - palm.y) * 8;
          centerOffset.z = 0;

          // Compression calculation - check all 5 fingertips
          const thumb = lm[4];
          const index = lm[8];
          const middle = lm[12];
          const ring = lm[16];
          const pinky = lm[20];
          const palmBase = lm[0];
          
          // Calculate average distance of all fingertips from palm
          const allDistances = [
            Math.sqrt(Math.pow(thumb.x - palmBase.x, 2) + Math.pow(thumb.y - palmBase.y, 2) + Math.pow(thumb.z - palmBase.z, 2)),
            Math.sqrt(Math.pow(index.x - palmBase.x, 2) + Math.pow(index.y - palmBase.y, 2) + Math.pow(index.z - palmBase.z, 2)),
            Math.sqrt(Math.pow(middle.x - palmBase.x, 2) + Math.pow(middle.y - palmBase.y, 2) + Math.pow(middle.z - palmBase.z, 2)),
            Math.sqrt(Math.pow(ring.x - palmBase.x, 2) + Math.pow(ring.y - palmBase.y, 2) + Math.pow(ring.z - palmBase.z, 2)),
            Math.sqrt(Math.pow(pinky.x - palmBase.x, 2) + Math.pow(pinky.y - palmBase.y, 2) + Math.pow(pinky.z - palmBase.z, 2))
          ];
          
          const avgDistance = allDistances.reduce((a, b) => a + b) / 5;
          
          // Galaxy expansion control: Open palm = expanded, Closed fist = contracted
          const closedThreshold = 0.04;  // Tight fist
          const openThreshold = 0.15;    // Open palm
          let compression = Math.max(0, Math.min(1, (avgDistance - closedThreshold) / (openThreshold - closedThreshold)));
          
          // Store compression globally for color updates
          currentCompression = compression;
          
          // Expansion mapping: 0.3 (tight galaxy) to 2.5 (expanded galaxy)
          const expansion = 0.3 + compression * 2.2;
          targetExpansion = expansion;

          // Gesture detection and galaxy control
          let gesture = "OPEN PALM";
          let statusColor = '#00ffff';
          let galaxyState = 'Stable';
          
          if (compression < 0.2) {
            gesture = "FIST";
            currentGesture = "FIST";
            galaxySpeed = 0.008; // Faster rotation when closed
            statusColor = '#ff4444';
            galaxyState = 'Contracting';
          } else if (compression < 0.6) {
            gesture = "PINCH";
            currentGesture = "PINCH";
            galaxySpeed = 0.005; // Medium rotation
            statusColor = '#ffaa00';
            galaxyState = 'Condensing';
          } else {
            gesture = "OPEN_PALM";
            currentGesture = "OPEN_PALM";
            galaxySpeed = 0.002; // Slow, majestic rotation
            statusColor = '#00ffff';
            galaxyState = 'Stable';
          }

          // Update HUD with galaxy status
          const galaxySize = currentExpansion.toFixed(2);
          const spiralTightnessValue = (spiralTightness * 10).toFixed(1);
          const rotationSpeed = (galaxySpeed * 1000).toFixed(3);

          hudEl.innerHTML = `
            <div style="color: ${statusColor};">üåå Galaxy Control Active</div>
            <div>State: <b style="color:${statusColor};">${galaxyState}</b></div>
            <div>Size: ${galaxySize}x | Speed: ${rotationSpeed}</div>
            <div>Spiral Arms: ${spiralTightnessValue} | Particles: 3000</div>
            <div>Center: (${centerOffset.x.toFixed(1)}, ${centerOffset.y.toFixed(1)})</div>
            <div style="font-size:11px; opacity:0.7; margin-top:5px;">
              ${gesture === "OPEN_PALM" ? "Open palm = Stable expanded galaxy" : 
                gesture === "FIST" ? "Closed fist = Contracted spinning galaxy" : 
                "Move hand to control galaxy position"}
            </div>
          `;
        } else {
          hudEl.innerHTML = `<div style="color: #f00;">‚ùå No hand detected - Please show your hand to camera</div>`;
        }
      });

      const camera = new window.Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 640,
        height: 480
      });

      camera.start();
    }

    // ====== STARTUP ======
    window.addEventListener('load', () => {
      if (typeof THREE !== 'undefined' && typeof window.Hands !== 'undefined' && typeof window.Camera !== 'undefined') {
        initThreeJS();
        initHandTracking();
      } else {
        setTimeout(() => {
          if (typeof THREE !== 'undefined' && typeof window.Hands !== 'undefined' && typeof window.Camera !== 'undefined') {
            initThreeJS();
            initHandTracking();
          } else {
            document.getElementById('hud').innerHTML = '<div style="color:#ff6b6b;">‚ùå Failed to load libraries</div>';
          }
        }, 1000);
      }
    });
  </script>
</body>
</html>
</html>
